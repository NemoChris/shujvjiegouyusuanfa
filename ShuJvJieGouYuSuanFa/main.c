//
//  main.c
//  ShuJvJieGouYuSuanFa
//
//  Created by 吴珊 on 2018/4/7.
//  Copyright © 2018年 吴珊. All rights reserved.
//

#include <stdio.h>
#include "ListByLink.h"
//#include "demo.h"
//#include "DuoXiangShi.h"
//#include <time.h>
//#include "StackByArray.h"
//#include "StackByLink.h"
//#include "ListByArr.h"
//typedef struct student_st
//{
//    char c;
//    int score;
//    const char *name;
//}student_st;
//
////栈的存储结构由一个数组和存储栈顶位置的变量组成
//typedef struct stack{
//    int top;
//    int data[10];
//}stack;

int main(int argc, const char * argv[]) {
    
    // method 3: 指定初始化，成员顺序可以不定
//    struct student_st s3 =
//    {
//    c: 'C',
//    score: 93,
//    name: "Wood",
//    };
    
//    stack s3 =
//    {
//        top: -1,
//        //data:{0},
//    };
//
//    stack *ptrS;
//    ptrS=&s3;
//
//    ptrS->data;
    

//    stack PtrS=CreateStack();
//    Push(&PtrS, 'A');
//    Push(&PtrS, 'B');
//    Push(&PtrS, 'C');
//    Push(&PtrS, 'D');
//    Pop(&PtrS);
//    Pop(&PtrS);
//    Pop(&PtrS);
//    Pop(&PtrS);
    
//    LinkStack *S=CreateStack();
//    Push('A', S);
//    Push('B', S);
//    Push('C', S);
//    Push('D', S);
//    Pop(S);
//    Pop(S);
//    Pop(S);
//    Pop(S);
//    Pop(S);
    
    //helloListByArr();
//    List *PtrL = MakeEmpty();
//    Insert(11, 0, PtrL);
//    Insert(12, 0, PtrL);
//    Insert(14, 0, PtrL);
//    Insert(9, 0, PtrL);
//    Insert(19, 0, PtrL);
//    Insert(29, 0, PtrL);
//    Insert(18, 0, PtrL);
//    int index=Find(11, PtrL);
//    index=Find(9, PtrL);
//    index=Find(15, PtrL);
//    int first=PtrL->Data[0];
//    int last=PtrL->Data[PtrL->Last];
//    Delete(1, PtrL);
//    Delete(3, PtrL);
//    Delete(11, PtrL);

//    List *PtrL=InsertOrCreate(1,1,NULL);
//    InsertOrCreate(2, 2, PtrL);
//    InsertOrCreate(3, 3, PtrL);
//    int length=Length(PtrL);
//    List *thirdNode=FindKth(3, PtrL);
//    List *fourthNode=FindKth(4, PtrL);
//    List *valueThreeNode=Find(3, PtrL);
//    List *valueFourNode=Find(4,PtrL);
//    Delete(3, PtrL);
//    Delete(3, PtrL);
//    Delete(2, PtrL);
//    PtrL = Delete(1, PtrL);
    
    return 0;
}


